package main

import "sync"

// HookFunc is the type of a hook callback function, receiving a slice of any value as arguments
// and returning one argument and an error.
type HookFunc func(a []interface{}) (interface{}, error)

// Hooks stores the hooks by various clients. A hook is a callback function.
type Hooks struct {
	cb   map[int]HookFunc
	lock sync.RWMutex
}

// NewHooks creates a new hooks repository.
func NewHooks() *Hooks {
	callbacks := make(map[int]HookFunc)
	return &Hooks{
		cb: callbacks,
	}
}

// Add adds the given hook for the ID. If a function already exists under that ID, it is overwritten.
func (h *Hooks) Add(id int, f HookFunc) {
	h.lock.Lock()
	defer h.lock.Unlock()
	h.cb[id] = f
}

// Exec executes the hook for given ID and arguments, if there is any. It does nothing if there is none.
func (h *Hooks) Exec(id int, args ...interface{}) {
	h.lock.RLock()
	defer h.lock.RUnlock()
	if f, ok := h.cb[id]; ok {
		f(args)
	}
}

// Remove the given hook, if it exists.
func (h *Hooks) Remove(id int) {
	h.lock.Lock()
	defer h.lock.Unlock()
	delete(h.cb, id)
}
